# !!! generated by ChatGPT because I never leared Flask before :) and we don't have enough time...

# app.py
from flask import Flask, request, jsonify
from flask_cors import CORS
import os, json, time

app = Flask(__name__)
CORS(app)

PLANT_FILE = "current_plant.txt"   # server-side; ESP32 will poll /current_plant and update its own last_plant.txt
UI_FILE    = "last_ui_state.json"  # last transformed snapshot for frontend

# --- tiny file helpers ---
def read_text(path):
    try:
        with open(path, "r", encoding="utf-8") as f:
            return f.read().strip()
    except:
        return ""

def write_text(path, content):
    with open(path, "w", encoding="utf-8") as f:
        f.write(content)

# --- your mapping (per your request) ---
STATE_EMOJI = {
    0: {"soil":"ðŸ¥µ dry",   "temp":"ðŸ¥¶ cold",  "light":"ðŸŒ‘ dark"},
    1: {"soil":"âœ… ok",    "temp":"âœ… ok",    "light":"âœ… ok"},
    2: {"soil":"ðŸ’¦ wet",   "temp":"ðŸ§¨ hot",   "light":"ðŸ”† bright"},
    4: {"soil":"â” err",   "temp":"â” err",    "light":"â” err"},
}

def to_ui_snapshot(payload: dict) -> dict:
    
    ss = int(payload.get("state_hum", 4))
    ts = int(payload.get("state_temp", 4))
    ls = int(payload.get("state_light", 4))

    # labels
    soil_label  = STATE_EMOJI.get(ss, STATE_EMOJI[4])["soil"]
    temp_label  = STATE_EMOJI.get(ts, STATE_EMOJI[4])["temp"]
    light_label = STATE_EMOJI.get(ls, STATE_EMOJI[4])["light"]

    # overall mood
    if 4 in (ss, ts, ls):
        mood = {"emoji":"â”", "text":"sensor?"}
    elif 2 in (ss, ts, ls) or 0 in (ss, ts, ls):
        mood = {"emoji":"ðŸ™", "text":"sad"}
    else:
        mood = {"emoji":"ðŸ™‚", "text":"happy"}

    return {
        "plant_id": payload.get("plant_id") or read_text(PLANT_FILE) or None,
        "soil":  {"state": ss, "label": soil_label},
        "temp":  {"state": ts, "label": temp_label},
        "light": {"state": ls, "label": light_label},
        "mood": mood,
        "ts": time.time()
    }

@app.get("/")
def root():
    return "Flask OK", 200

# 1) Frontend sends plant choice -> server stores it (no default set here)
@app.post("/set_plant")
def set_plant():
    data = request.get_json(silent=True) or {}
    pid = (data.get("plant_id") or "").strip()
    if not pid:
        return jsonify({"ok": False, "error": "missing plant_id"}), 400
    write_text(PLANT_FILE, pid)
    return jsonify({"ok": True, "plant_id": pid}), 200

# ESP32 polls this; if no plant set yet -> 204 so ESP keeps its own last_plant.txt
@app.get("/current_plant")
def current_plant():
    if not os.path.exists(PLANT_FILE):
        return ("", 204)
    pid = read_text(PLANT_FILE)
    if not pid:
        return ("", 204)
    return jsonify({"plant_id": pid}), 200

# 2) ESP32 posts telemetry (your keys) -> server transforms + stores snapshot
@app.post("/telemetry")
def telemetry():
    data = request.get_json(silent=True) or {}
    ui = to_ui_snapshot(data)
    write_text(UI_FILE, json.dumps(ui, ensure_ascii=False))
    return jsonify({"ok": True}), 200

# Frontend polls this to display emojis & labels
@app.get("/ui_state")
def ui_state():
    raw = read_text(UI_FILE)
    if not raw:
        return jsonify({"mood":{"emoji":"âŒ›","text":"waiting"}}), 200
    return app.response_class(raw, mimetype="application/json")

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5001, debug=True)